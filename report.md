# Linux Network. Сети в Linux

## Linux networks configuration on virtual machines. 
### Настройка сетей в Linux на виртуальных машинах.

## Contents
1. [Part 1. ipcalc tool. Инструмент ipcalc](#part-1-ipcalc-tool)
2. [Part 2. Static routing between two machines. Статическая маршрутизация между двумя машинами](#part-2-static-routing-between-two-machines)
3. [Part 3. iperf3 utility. Утилита iperf3](#part-3-iperf3-utility)
4. [Part 4. Network firewall. Сетевой экран](#part-4-network-firewall)
5. [Part 5. Static network routing. Статическая маршрутизация сети](#part-5-static-network-routing)

## Part 1. ipcalc tool 
### Инструмент ipcalc
- ### 1.1  Cети и маски

#### 1) `Определить и записать адрес сети 192.167.38.54/13`

> `ipcalc` - инструмент linux, который помогает рассчитать IP-адрес подсети. Он принимает на вход IP-адрес и маску сети и на выходе мы получаем адрес сети, широковещательный адрес, минимальный и максимальный хост и общее количество хостов.

```c
$ sudo apt install ipcalc
$ ipcalc 192.167.38.54/13
```
![1.1 ipcalc output](pics/1.1%20ipcalc%20output.png)

`адрес сети:` 192.167.0.0/13

#### 2) `Определить и записать перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную`

Перевод маски `255.255.255.0` в префиксную запись: `/24`

Перевод маски `255.255.255.0` в двоичную запись: `11111111.11111111.11111111.00000000`

Перевод маски `/15` в двоичную запись: `11111111.11111110.00000000.00000000`

Перевод маски `/15` в десятичную запись: `255.254.0.0`

Перевод маски `11111111.11111111.11111111.11110000` в десятичную запись: `255.255.255.240`

Перевод маски `11111111.11111111.11111111.11110000` в префиксную запись: `/28`

#### 3) `Определить и записать минимальный и максимальный хост в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4`

![1.3.1 ipcalc output](pics/1.3.1ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/8:` `12.255.255.254`

Минимальный хост в сети `12.167.38.4/8:` `12.0.0.1`

![1.3.2 ipcalc output](pics/1.3.2%20ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/16:` `12.167.255.254`

Минимальный хост в сети `12.167.38.4/16:` `12.167.0.1`

![1.3.3 ipcalc output](pics/1.3.3%20ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/255.255.254.0:` `12.167.39.254`

Минимальный хост в сети `12.167.38.4/255.255.254.0:` `12.167.38.1`

![1.3.4 ipcalc output](pics/1.3.4%20ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/4:` `15.255.255.254`

Минимальный хост в сети `12.167.38.4/4:` `0.0.0.1`

- ### 1.2  localhost
#### `Определить, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1`

Для определения доступности приложения на localhost можно воспользоваться командой:
```c
$ ping <address>
```
Если приложение доступно, то вы получите ответы от удаленного компьютера. Если же приложение недоступно, то вы получите сообщение об ошибке.

![1.4.1 ping output](pics/1.4.1%20ping%20output.png)

![1.4.2 ping output](pics/1.4.2%20ping%20output.png)

![1.4.3 ping output](pics/1.4.3%20ping%20output.png)

![1.4.4 ping output](pics/1.4.4%20ping%20output.png)

- ### 1.3  Диапазоны и сегменты сетей

#### 1) `Определить, какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1`

С помощью команды `ipcalc` в Linux можно определить тип сети (приватная/частная или публичная) на основе IP-адреса и маски подсети.

![1.5.1 ipcalc output](pics/1.5.1%20ipcalc%20output.png)
- private

![1.5.2 ipcalc output](pics/1.5.2%20ipcalc%20output.png)
- public

![1.5.3 ipcalc output](pics/1.5.3%20ipcalc%20output.png)
- private

![1.5.4 ipcalc output](pics/1.5.4%20ipcalc%20output.png)
- private

![1.5.5 ipcalc output](pics/1.5.5%20ipcalc%20output.png)
- public

![1.5.6 ipcalc output](pics/1.5.6%20ipcalc%20output.png)
- public

![1.5.7 ipcalc output](pics/1.5.7%20ipcalc%20output.png)
- public

![1.5.8 ipcalc output](pics/1.5.8%20ipcalc%20output.png)
- private

![1.5.9 ipcalc output](pics/1.5.9%20ipcalc%20output.png)
- private

![1.5.10 ipcalc output](pics/1.5.10%20ipcalc%20output.png)
- public

#### 2) `Определить какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255`

Чтобы определить, какие IP адреса шлюза возможны у сети 10.10.0.0/18, нужно определить максимальный и минимальный хост сети. Если IP адрес находится в подходящем диапазоне, значит он может быть использован в данной подсети.

![1.6.1 ipcalc output](pics/1.6.1%20ipcalc%20output.png)
Минимальный хост: `10.10.0.1`

Максимальный хост: `10.10.63.254`

Теперь можно сравнить предложенные адреса с нужным диапазоном:

- `10.0.0.1` не входит в диапазон, значит не возможен.

- `10.10.0.2` входит в диапазон, а значит возможен.

- `10.10.10.10` входит в диапазон, а значит возможен.

- `10.10.100.1` не входит в диапазон, значит не возможен.

- `10.10.1.255` входит в диапазон, а значит возможен.

## Part 2. Static routing between two machines
### Статическая маршрутизация между двумя машинами

#### `Поднять две виртуальные машины. С помощью команды ip a посмотреть существующие сетевые интерфейсы.` 

ws1:
![2.1 ip a output](pics/2.1%20ip%20a%20output.png)

ws2:
![2.2 ip a output](pics/2.2%20ip%20a%20output.png)

#### `Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12.`

Проверяем внутренний ip-адрес машины:
```c
$ ip route
```
ws1:
![2.3 ip route output](pics/2.3%20ip%20route%20output.png)
ws2:
![2.4 ip route output](pics/2.4%20ip%20route%20output.png)

Чтобы задать адрес и маску устройству, открываем файл etc/netplan/00-installer-config.yaml и вносим изменения в строку адреса:

```c
$ sudo vim /etc/netplan/00-installer-config.yaml
```
ws1:
![2.5 address change](pics/2.5%20address%20change.png)

ws2:
![2.6 address change](pics/2.6%20address%20change.png)

Выполняем команду `netplan apply` для перезапуска сервиса сети и проверяем, изменился ли адрес:
```c
$ sudo netplan apply
$ ip a
```
ws1:
![2.7 netplan apply](pics/2.7%20netplan%20apply.png)

ws2:
![2.8 netplan apply](pics/2.8%20netplan%20apply%20.png)

- ### 2.1 Добавление статического маршрута вручную
#### `Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add. Пропинговать соединение между машинами.`

ws1:
```c
$ sudo ip r add 172.24.116.8 dev enp0s8
```
> `r` - route

Проверяем:
```c
$ ip route
```
![2.9 ip route](pics/2.9%20ip%20route.png)

```c
$ ping -c 4 172.24.116.8
```
![2.11 ping](pics/2.11%20ping.png)

> `-c` указывает количество передаваемых пакетов

ws2:
```c
$ sudo ip r add 192.168.100.10 dev enp0s8
```
Проверяем:
```c
$ ip route
```
![2.10 ip route](pics/2.10%20ip%20route.png)
```c
$ ping -c 4 192.168.100.10
```
![2.12 ping](pics/2.12%20ping.png)

- ### 2.2. Добавление статического маршрута с сохранением
#### `Перезапустить машины. Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml. Пропинговать соединение между машинами.`

```c
$ reboot
```
Открываем etc/netplan/00-installer-config.yaml и добавляем настройки:

ws1:
![2.13 change route](pics/2.13%20change%20route.png)

Перезапускаем сервис сети:
```c
$ sudo netplan apply
```

Проверяем:
```c
$ ip r
```
> `r` - route

![12.15 ip route](pics/2.15%20ip%20route.png)

```c
$ ping -c 4 172.24.116.8
```
![2.17 ping](pics/2.17%20ping.png)

ws2:
![2.14 change route](pics/2.14%20change%20route.png)

Перезапускаем сервис сети:
```c
$ sudo netplan apply
```
Проверяем:
```c
$ ip route
```
![12.16 ip route](pics/2.16%20ip%20route.png)

```c
$ ping -c 4 192.168.100.10
```
![2.18 ping](pics/2.18%20ping.png)

## Part 3. iperf3 utility
### Утилита iperf3

- ### 3.1 Скорость соединения
#### `Перевести и записать: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps.`

> `Mbps (Мбит)` -  мегабит/c, 1 Mbps = 1000000 Bps

> `MB/s (Мбайт)` - мегабайт/c, 1 MB = 8 Mbps

> `Kbps (Кбит)` - килобит/c, 1 Mbps = 1000 Kbps

> `Gbps (Гбит)` - гигабит/c, 1 Gbps = 1000 Mbps

- 8 Mbps = 1 MB/s
- 100 MB/s = 800000 Kbps
- 1 Gbps = 1000 Mbps

- ### 3.2 Утилита iperf3
#### `Измерить скорость соединения между ws1 и ws2.`

> `iperf3` - позволяет измерить максимальную пропускную способность между двумя узлами сети.

```c
$ sudo apt install iperf3
```

Запускаем `iperf3` на ws1 в режиме сервер с флагом -s. Она будет ожидать пока не запустится этаже утилита на ws2 в режиме клиента.

```c
$ iperf3 -s
```
![3.1 iperf3](pics/3.1%20iperf3.png)

Запускаем на ws2 `iperf3` в режиме клиент с флагом -c и указываем IP-адрес ws1.

```c
$ iperf3 -c 192.168.100.10
```
![3.2 iperf3](pics/3.2%20iperf3.png)

## Part 4. Network firewall
### Сетевой экран

- ### 4.1 Утилита iptables
#### `Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2.`

> `iptables` - инструмент управления сетью в Linux, который позволяет администраторам управлять входящими и исходящими пакетами данных. Это основной инструмент для настройки межсетевых экранов (брандмауэр/firewall) в системах Linux. Iptables работает путем проверки пакетов данных на соответствие определенным критериям и выполнения заданных действий, если пакеты соответствуют этим критериям. Эти критерии и действия определяются в таблицах, которые состоят из набора правил.

```c
$ sudo apt install iptables
```
Созадем файл /etc/firewall.sh:
```c
$ sudo touch /etc/firewall.sh
```
`Нужно добавить в файл подряд следующие правила:`

`1) на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5).`

`2) на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5).`

`3) открыть на машинах доступ для порта 22 (ssh) и порта 80 (http).`

`4) запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT).`

`5) разрешить echo reply (машина должна "пинговаться").`

Разница между стратегиями, применёнными в первом и втором файлах, заключается в следующем: в утилите iptables правила выполняются сверху вниз. На первой машине первым указано запрещающее правило на выход, поэтому она не сможет пропинговать другую машину. У второй машины, наоброт - первым указано разрешающее правило, значит она сможет пропинговать другую машину.

```c
$ sudo vim /etc/firewall.sh
```

> Синтаксис iptables: `iptables -t [таблица] [команда] [цепочка] [критерии] [действие]`

> `-F` - команда (сброс всех правил из заданной цепочки (таблицы). Если имя цепочки и таблицы не указывается, то удаляются все правила, во всех цепочках)

> `-X` - команда (удаление заданной цепочки из заданной таблицы)

> `-A` - команда (добавляет новое правило в конец заданной цепочки)

> `INPUT / OUTPUT` - цепочка

> `-p` - критерий (для указания типа протокола)

> `--dport` - критерий (добавить порт)

> `--icmp-type 8` - критерий. Тип сообщения ICMP определяется номером. `8` - Echo Reply

> `-j` - критерий (выбрать действие, если правило подошло)

> `ACCEPT` - действие (разрешить прохождение пакета дальше по цепочке правил)

> `DROP` - действие (удалить пакет)

ws1:

![4.1 iptables](pics/4.1%20iptables.png)

ws2:

![4.2 iptables](pics/4.2%20iptables.png)

Делаем файл исполняемым, запускаем и проверяем, пингуются ли машины между собой:
```c
$ sudo chmod +x firewall.sh
$ sudo sh firewall.sh
$ ping <address>
```

ws1:
![4.3 firewall](pics/4.3%20firewall.png)

Операция была отклонена, пакеты не получены.

ws2:
![4.4 firewall](pics/4.4%20firewall.png)

Все пакеты переданы успешно.

- ### 4.2 Утилита nmap
#### `Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен.`

ws1:

![4.5 ping](pics/4.5%20ping.png)

ws2:

![4.6 ping](pics/4.6%20ping.png)

Видим, что ws1 не пингуется.

> `nmap` - сканер сети, который помогает понять какие компьютеры подключены к сети, узнать их имена, а также посмотреть какое программное обеспечение на них установлено, какая операционная система и какие типы фильтров применяются. Утилита nmap в процессе сканирования сети перебирает доступный диапазон портов и пытается подключиться к каждому из них. Если подключение удалось, в большинстве случаев, передав несколько пакетов программа может даже узнать версию программного обеспечения, которые ожидает подключений к этому порту.

```c
$ sudo apt install nmap
```
> Синтаксис Nmap: nmap [опции] [адрес]

ws1:
![4.7 nmap](pics/4.7%20nmap.png)

ws2:
![4.8 namp](pics/4.8%20nmap.png)

## Part 5. Static network routing
### Статическая маршрутизация сети

- ### 5.1. Настройка адресов машин
#### `Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.`

![5.1 scheme](pics/5.1%20scheme.png)

