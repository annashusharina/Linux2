# Linux Network. Сети в Linux

## Linux networks configuration on virtual machines. 
### Настройка сетей в Linux на виртуальных машинах.

## Contents
1. [Part 1. ipcalc tool. Инструмент ipcalc](#part-1-ipcalc-tool)
2. [Part 2. Static routing between two machines. Статическая маршрутизация между двумя машинами](#part-2-static-routing-between-two-machines)
3. [Part 3. iperf3 utility. Утилита iperf3](#part-3-iperf3-utility)
4. [Part 4. Network firewall. Сетевой экран](#part-4-network-firewall)
5. [Part 5. Static network routing. Статическая маршрутизация сети](#part-5-static-network-routing)
6. [Part 6. Dynamic IP configuration using DHCP. Динамическая настройка IP с помощью DHCP](#part-6-dynamic-ip-configuration-using-dhcp)
7. [Part 7. NAT](#part-7-nat)
8. [Bonus. Introduction to SSH Tunnels. Дополнительно. Знакомство с SSH Tunnels](#part-8-bonus-introduction-to-ssh-tunnels)

## Part 1. ipcalc tool 
### Инструмент ipcalc
- ### 1.1  Cети и маски

#### 1) `Определить и записать адрес сети 192.167.38.54/13`

> `ipcalc` - инструмент linux, который помогает рассчитать IP-адрес подсети. Он принимает на вход IP-адрес и маску сети и на выходе мы получаем адрес сети, широковещательный адрес, минимальный и максимальный хост и общее количество хостов.

```c
$ sudo apt install ipcalc
$ ipcalc 192.167.38.54/13
```
![1.1 ipcalc output](pics/1.1%20ipcalc%20output.png)

`адрес сети:` 192.167.0.0/13

#### 2) `Определить и записать перевод маски 255.255.255.0 в префиксную и двоичную запись, /15 в обычную и двоичную, 11111111.11111111.11111111.11110000 в обычную и префиксную`

Перевод маски `255.255.255.0` в префиксную запись: `/24`

Перевод маски `255.255.255.0` в двоичную запись: `11111111.11111111.11111111.00000000`

Перевод маски `/15` в двоичную запись: `11111111.11111110.00000000.00000000`

Перевод маски `/15` в десятичную запись: `255.254.0.0`

Перевод маски `11111111.11111111.11111111.11110000` в десятичную запись: `255.255.255.240`

Перевод маски `11111111.11111111.11111111.11110000` в префиксную запись: `/28`

#### 3) `Определить и записать минимальный и максимальный хост в сети 12.167.38.4 при масках: /8, 11111111.11111111.00000000.00000000, 255.255.254.0 и /4`

![1.3.1 ipcalc output](pics/1.3.1ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/8:` `12.255.255.254`

Минимальный хост в сети `12.167.38.4/8:` `12.0.0.1`

![1.3.2 ipcalc output](pics/1.3.2%20ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/16:` `12.167.255.254`

Минимальный хост в сети `12.167.38.4/16:` `12.167.0.1`

![1.3.3 ipcalc output](pics/1.3.3%20ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/255.255.254.0:` `12.167.39.254`

Минимальный хост в сети `12.167.38.4/255.255.254.0:` `12.167.38.1`

![1.3.4 ipcalc output](pics/1.3.4%20ipcalc%20output.png)

Максимальный хост в сети `12.167.38.4/4:` `15.255.255.254`

Минимальный хост в сети `12.167.38.4/4:` `0.0.0.1`

- ### 1.2  localhost
#### `Определить, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1`

Для определения доступности приложения на localhost можно воспользоваться командой:
```c
$ ping <address>
```
Если приложение доступно, то вы получите ответы от удаленного компьютера. Если же приложение недоступно, то вы получите сообщение об ошибке.

![1.4.1 ping output](pics/1.4.1%20ping%20output.png)

![1.4.2 ping output](pics/1.4.2%20ping%20output.png)

![1.4.3 ping output](pics/1.4.3%20ping%20output.png)

![1.4.4 ping output](pics/1.4.4%20ping%20output.png)

- ### 1.3  Диапазоны и сегменты сетей

#### 1) `Определить, какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1`

С помощью команды `ipcalc` в Linux можно определить тип сети (приватная/частная или публичная) на основе IP-адреса и маски подсети.

![1.5.1 ipcalc output](pics/1.5.1%20ipcalc%20output.png)
- private

![1.5.2 ipcalc output](pics/1.5.2%20ipcalc%20output.png)
- public

![1.5.3 ipcalc output](pics/1.5.3%20ipcalc%20output.png)
- private

![1.5.4 ipcalc output](pics/1.5.4%20ipcalc%20output.png)
- private

![1.5.5 ipcalc output](pics/1.5.5%20ipcalc%20output.png)
- public

![1.5.6 ipcalc output](pics/1.5.6%20ipcalc%20output.png)
- public

![1.5.7 ipcalc output](pics/1.5.7%20ipcalc%20output.png)
- public

![1.5.8 ipcalc output](pics/1.5.8%20ipcalc%20output.png)
- private

![1.5.9 ipcalc output](pics/1.5.9%20ipcalc%20output.png)
- private

![1.5.10 ipcalc output](pics/1.5.10%20ipcalc%20output.png)
- public

#### 2) `Определить какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255`

Чтобы определить, какие IP адреса шлюза возможны у сети 10.10.0.0/18, нужно определить максимальный и минимальный хост сети. Если IP адрес находится в подходящем диапазоне, значит он может быть использован в данной подсети.

![1.6.1 ipcalc output](pics/1.6.1%20ipcalc%20output.png)
Минимальный хост: `10.10.0.1`

Максимальный хост: `10.10.63.254`

Теперь можно сравнить предложенные адреса с нужным диапазоном:

- `10.0.0.1` не входит в диапазон, значит не возможен.

- `10.10.0.2` входит в диапазон, а значит возможен.

- `10.10.10.10` входит в диапазон, а значит возможен.

- `10.10.100.1` не входит в диапазон, значит не возможен.

- `10.10.1.255` входит в диапазон, а значит возможен.

## Part 2. Static routing between two machines
### Статическая маршрутизация между двумя машинами

#### `Поднять две виртуальные машины. С помощью команды ip a посмотреть существующие сетевые интерфейсы.` 

ws1:
![2.1 ip a output](pics/2.1%20ip%20a%20output.png)

ws2:
![2.2 ip a output](pics/2.2%20ip%20a%20output.png)

#### `Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски: ws1 - 192.168.100.10, маска /16, ws2 - 172.24.116.8, маска /12.`

Проверяем внутренний ip-адрес машины:
```c
$ ip route
```
ws1:
![2.3 ip route output](pics/2.3%20ip%20route%20output.png)
ws2:
![2.4 ip route output](pics/2.4%20ip%20route%20output.png)

Чтобы задать адрес и маску устройству, открываем файл etc/netplan/00-installer-config.yaml и вносим изменения в строку адреса:

```c
$ sudo vim /etc/netplan/00-installer-config.yaml
```
ws1:
![2.5 address change](pics/2.5%20address%20change.png)

ws2:
![2.6 address change](pics/2.6%20address%20change.png)

Выполняем команду `netplan apply` для перезапуска сервиса сети и проверяем, изменился ли адрес:
```c
$ sudo netplan apply
$ ip a
```
ws1:
![2.7 netplan apply](pics/2.7%20netplan%20apply.png)

ws2:
![2.8 netplan apply](pics/2.8%20netplan%20apply%20.png)

- ### 2.1 Добавление статического маршрута вручную
#### `Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add. Пропинговать соединение между машинами.`

ws1:
```c
$ sudo ip r add 172.24.116.8 dev enp0s8
```
> `r` - route

Проверяем:
```c
$ ip route
```
![2.9 ip route](pics/2.9%20ip%20route.png)

```c
$ ping -c 4 172.24.116.8
```
![2.11 ping](pics/2.11%20ping.png)

> `-c` указывает количество передаваемых пакетов

ws2:
```c
$ sudo ip r add 192.168.100.10 dev enp0s8
```
Проверяем:
```c
$ ip route
```
![2.10 ip route](pics/2.10%20ip%20route.png)
```c
$ ping -c 4 192.168.100.10
```
![2.12 ping](pics/2.12%20ping.png)

- ### 2.2. Добавление статического маршрута с сохранением
#### `Перезапустить машины. Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml. Пропинговать соединение между машинами.`

```c
$ reboot
```
Открываем etc/netplan/00-installer-config.yaml и добавляем настройки:

ws1:
![2.13 change route](pics/2.13%20change%20route.png)

Перезапускаем сервис сети:
```c
$ sudo netplan apply
```

Проверяем:
```c
$ ip r
```
> `r` - route

![12.15 ip route](pics/2.15%20ip%20route.png)

```c
$ ping -c 4 172.24.116.8
```
![2.17 ping](pics/2.17%20ping.png)

ws2:
![2.14 change route](pics/2.14%20change%20route.png)

Перезапускаем сервис сети:
```c
$ sudo netplan apply
```
Проверяем:
```c
$ ip route
```
![12.16 ip route](pics/2.16%20ip%20route.png)

```c
$ ping -c 4 192.168.100.10
```
![2.18 ping](pics/2.18%20ping.png)

## Part 3. iperf3 utility
### Утилита iperf3

- ### 3.1 Скорость соединения
#### `Перевести и записать: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps.`

> `Mbps (Мбит)` -  мегабит/c, 1 Mbps = 1000000 Bps

> `MB/s (Мбайт)` - мегабайт/c, 1 MB = 8 Mbps

> `Kbps (Кбит)` - килобит/c, 1 Mbps = 1000 Kbps

> `Gbps (Гбит)` - гигабит/c, 1 Gbps = 1000 Mbps

- 8 Mbps = 1 MB/s
- 100 MB/s = 800000 Kbps
- 1 Gbps = 1000 Mbps

- ### 3.2 Утилита iperf3
#### `Измерить скорость соединения между ws1 и ws2.`

> `iperf3` - позволяет измерить максимальную пропускную способность между двумя узлами сети.

```c
$ sudo apt install iperf3
```

Запускаем `iperf3` на ws1 в режиме сервер с флагом -s. Она будет ожидать пока не запустится этаже утилита на ws2 в режиме клиента.

```c
$ iperf3 -s
```
![3.1 iperf3](pics/3.1%20iperf3.png)

Запускаем на ws2 `iperf3` в режиме клиент с флагом -c и указываем IP-адрес ws1.

```c
$ iperf3 -c 192.168.100.10
```
![3.2 iperf3](pics/3.2%20iperf3.png)

## Part 4. Network firewall
### Сетевой экран

- ### 4.1 Утилита iptables
#### `Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2.`

> `iptables` - инструмент управления сетью в Linux, который позволяет администраторам управлять входящими и исходящими пакетами данных. Это основной инструмент для настройки межсетевых экранов (брандмауэр/firewall) в системах Linux. Iptables работает путем проверки пакетов данных на соответствие определенным критериям и выполнения заданных действий, если пакеты соответствуют этим критериям. Эти критерии и действия определяются в таблицах, которые состоят из набора правил.

```c
$ sudo apt install iptables
```
Созадем файл /etc/firewall.sh:

```c
$ sudo touch /etc/firewall.sh
```
`Нужно добавить в файл подряд следующие правила:`

`1) на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5).`

`2) на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5).`

`3) открыть на машинах доступ для порта 22 (ssh) и порта 80 (http).`

`4) запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT).`

`5) разрешить echo reply (машина должна "пинговаться").`

Разница между стратегиями, применёнными в первом и втором файлах, заключается в следующем: в утилите iptables правила выполняются сверху вниз. На первой машине первым указано запрещающее правило на выход, поэтому она не сможет пропинговать другую машину. У второй машины, наоброт - первым указано разрешающее правило, значит она сможет пропинговать другую машину.

```c
$ sudo vim /etc/firewall.sh
```

> Синтаксис iptables: `iptables -t [таблица] [команда] [цепочка] [критерии] [действие]`

> `-F` - команда (сброс всех правил из заданной цепочки (таблицы). Если имя цепочки и таблицы не указывается, то удаляются все правила, во всех цепочках)

> `-X` - команда (удаление заданной цепочки из заданной таблицы)

> `-A` - команда (добавляет новое правило в конец заданной цепочки)

> `INPUT / OUTPUT` - цепочка

> `-p` - критерий (для указания типа протокола)

> `--dport` - критерий (добавить порт)

> `--icmp-type 8` - критерий. Тип сообщения ICMP определяется номером. `8` - Echo Reply

> `-j` - критерий (выбрать действие, если правило подошло)

> `ACCEPT` - действие (разрешить прохождение пакета дальше по цепочке правил)

> `DROP` - действие (удалить пакет)

ws1:

![4.1 iptables](pics/4.1%20iptables.png)

ws2:

![4.2 iptables](pics/4.2%20iptables.png)

Делаем файл исполняемым, запускаем и проверяем, пингуются ли машины между собой:
```c
$ sudo chmod +x /etc/firewall.sh
$ sudo sh /etc/firewall.sh
$ ping <address>
```

ws1:
![4.3 firewall](pics/4.3%20firewall.png)

Операция была отклонена, пакеты не получены.

ws2:
![4.4 firewall](pics/4.4%20firewall.png)

Все пакеты переданы успешно.

- ### 4.2 Утилита nmap
#### `Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен.`

ws1:

![4.5 ping](pics/4.5%20ping.png)

ws2:

![4.6 ping](pics/4.6%20ping.png)

Видим, что ws1 не пингуется.

> `nmap` - сканер сети, который помогает понять какие компьютеры подключены к сети, узнать их имена, а также посмотреть какое программное обеспечение на них установлено, какая операционная система и какие типы фильтров применяются. Утилита nmap в процессе сканирования сети перебирает доступный диапазон портов и пытается подключиться к каждому из них. Если подключение удалось, в большинстве случаев, передав несколько пакетов программа может даже узнать версию программного обеспечения, которые ожидает подключений к этому порту.

```c
$ sudo apt install nmap
```
> Синтаксис Nmap: nmap [опции] [адрес]

ws1:
![4.7 nmap](pics/4.7%20nmap.png)

ws2:
![4.8 namp](pics/4.8%20nmap.png)

## Part 5. Static network routing
### Статическая маршрутизация сети

- ### 5.1. Настройка адресов машин
#### `Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.`

![5.1 scheme](pics/5.1%20scheme.png)

Чтобы настроить конфигурации соединений, открываем /etc/netplan/00-installer-config.yaml. Меняем адрес хоста.

```c
$ sudo vim /etc/netplan/00-installer-config.yaml
```
ws11:

![5.2 ws11 config](pics/5.2%20ws11%20config.png)

ws22:

![5.8 ws22 config](pics/5.8%20ws22%20config.png)

ws21:

![5.9 ws21 config](pics/5.9%20ws21%20config.png)

r1:

![5.5 r1 config](pics/5.5%20r1%20config.png)

r2:

![5.10 r2 config](pics/5.10%20r2%20config.png)

#### `Перезапустить сервис сети. Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно. Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.`

Перезапускаем сервис сети. Проверяем доступные сетевые интерфейсы с помощью `ip -4 a`. Проверяем, добавлен ли маршрут, и пингуем.
```c
$ sudo netplan apply
$ ip -4 a
$ ping -c 4 <address>
```
Пингуем ws11 и r1:

![5.3 ws11 ip a](pics/5.3%20ws11%20ip%20a.png)

![5.4 ws11 ping](pics/5.4%20ws11%20ping.png)

Пингуем r1 и ws11:

![5.6 r1 ip a](pics/5.6%20r1%20ip%20a.png)

![5.4 r1 ping](pics/5.7%20r1%20ping.png)

Пингуем ws22 и ws21:

![5.11 ws22 ip a](pics/5.11%20ws22%20ip%20a.png)

![5.12 ws22 ping](pics/5.12%20ws22%20ping.png)

Пингуем ws21 и ws22:

![5.13 ws21 ip a](pics/5.13%20ws21%20ip%20a.png)

![5.14 ws21 ping](pics/5.14%20ws21%20ping.png)

- ### 5.2. Включение переадресации IP-адресов
#### `Для включения переадресации IP, выполните команду на роутерах:`

```c
$ sudo sysctl -w net.ipv4.ip_forward=1

```
> `-w net.ipv4.ip_forward=1` - включить пересылку пакетов IPv4

r1:
![5.15 r1 sysctl](pics/5.15%20r1%20sysctl.png)

r2:
![5.16 r2 sysctl](pics/5.16%20r2%20sysctl.png)

При таком подходе переадресация не будет работать после перезагрузки системы.

#### `Откройте файл /etc/sysctl.conf и добавьте в него следующую строку:`

```c
$ net.ipv4.ip_forward = 1
```

r1:
![5.17 r1 sysctl config](pics/5.17%20r1%20sysctl%20config.png)

r2:
![5.18 r2 sysctl config](pics/5.18%20r2%20sysctl%20config.png)

При использовании этого подхода, IP-переадресация включена на постоянной основе.

- ### 5.3. Установка маршрута по-умолчанию
#### `Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить default перед IP роутера в файле конфигураций.`

ws11:
![5.19 ws11 route config](pics/5.19%20ws11%20route%20config.png)

ws22:
![5.20 ws22 route config](pics/5.20%20ws22%20route%20config.png)

ws21:
![5.21 ws21 route config](pics/5.21%20ws21%20route%20config.png)

Перезапускаем сервис сети:
```c
$ sudo netplan apply
```

#### `Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации.`

ws11:
![5.22 ws11 ip a](pics/5.22%20ws11%20ip%20r.png)

ws22:
![5.23 ws22 ip a](pics/5.23%20ws22%20ip%20a.png)

ws21:
![5.24 ws21 ip a](pics/5.24%20ws21%20ip%20a.png)

#### `Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду:`

```c
$ sudo tcpdump -tn -i eth1
```

> `tcpdump` - позволяет просматривать все входящие и исходящие из определенного интерфейса пакеты.

> `-i` - интерфейс
> `-t` - не отображать доменные имена
> `-n` - не отображать временную метку

r2:
![5.25 r2 tcpdump](pics/5.25%20r2%20tcpdump.png)

Видим, что пинг доходит.

ws11:
![5.26 ws11 ping](pics/5.26%20ws11%20ping.png)

- ### 5.4. Добавление статических маршрутов
#### `Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Вызвать ip r и показать таблицы с маршрутами на обоих роутерах.`

r1:
![5.27 r1 config](pics/5.27%20r1%20config.png)

![5.28 r1 ip r](pics/5.28%20r1%20ip%20r.png)

r2:
![5.29 r2 config](pics/5.29%20r2%20config.png)

![5.30 r1 ip r](pics/5.30%20r2%20ip%20r.png)

#### `Запустить команды на ws11:`
```c
$ ip r list 10.10.0.0/[маска сети] и ip r list 0.0.0.0/0
```

![5.31 ws11 ip r list](pics/5.31%20ws11%20ip%20r%20list.png)

Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0 (он попадает под маршрут по-умолчанию), т.к. машина 10.10.0.0/18 имеет более длинную маску, поэтому был выбран этот маршрут, а не маршрут по умолчанию.

- ### 5.5. Построение списка маршрутизаторов

> `traceroute` - позволяет проследить маршрут следования данных до удаленного адресата в сетях TCP/IP.

#### `Запустить на r1 команду дампа. При помощи утилиты traceroute построить список маршрутизаторов на пути от ws11 до ws21.`

```c
$ sudo tcpdump -tnv -i eth0
```
> `-v` - более подробный вывод

r1:
![5.33 r1 tcpdump](pics/5.33%20r1%20tcpdump.png)

ws11:
![5.32 ws11 traceroute](pics/5.32%20ws11%20traceroute.png)

Можем увидеть, что пакет прошел через 3 узла перед тем, как дойти до цели.

Каждый пакет проходит на своем пути определенное количество узлов, пока достигнет своей цели. Причем, каждый пакет имеет свое время жизни. Это количество узлов, которые может пройти пакет перед тем, как он будет уничтожен. Этот параметр записывается в заголовке TTL, каждый маршрутизатор, через который будет проходить пакет уменьшает его на единицу. При TTL=0 пакет уничтожается, а отправителю отсылается сообщение Time Exceeded.Команда traceroute linux использует UDP пакеты. Она отправляет пакет с TTL=1 и смотрит адрес ответившего узла, дальше TTL=2, TTL=3 и так пока не достигнет цели. Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят. Когда утилита traceroute получает сообщение от целевого узла о том, что порт недоступен трассировка считается завершенной.

- ### 5.6. Использование протокола ICMP при маршрутизации
#### `Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:`

```c
$ sudo tcpdump -n -i eth0 icmp
```
> `icmp` Internet Control Message Protocol 

#### `Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:`

```c
$ ping -c 1 10.30.0.111
```
ws11:
![5.35 ws11 ping](pics/5.35%20ws11%20ping.png)

r1:
![5.34 r1 tcpdump](pics/5.34%20r1%20tcpdump.png)

Видим, что был перехвачен 1 пакет.

## Part 6. Dynamic IP configuration using DHCP
### Динамическая настройка IP с помощью DHCP

#### 1) `Для r2 настроить в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP. указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети.`

```c
$ sudo apt-get install ics-dhcp-server
```
Для начала определим сетевые интерфейсы и пропишем их в конфигурационный файл:

```c
$ sudo vim /etc/default/isc-dhcp-server
```

![5.36 r2 interfaces config](pics/5.36%20r2%20interfaces%20config.png)

Теперь нужно отредактировать dhcpd.conf. Укажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети, диапазон IP адресов:

```c
$ sudo vim /etc/dhcp/dhcpd.conf
```
![5.37 r2 dhcp config](pics/5.37%20r2%20dhcp%20config.png)

#### 2) `В файле resolv.conf прописать nameserver 8.8.8.8.`

Файл resolv.conf содержит адреса серверов имен, к которым система имеет доступ.

```c
$ sudo vim /etc/resolv.conf
```

![5.38 r2 nemeserver](pics/5.38%20r2%20nemeserver.png)

`Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.`

![5.39 r2 dhcp restart](pics/5.39%20r2%20dhcp%20restart.png)

Изменим настройки машин ws21 и ws22 в файле конфигурации, чтобы сделать протокол DHCP активным.

```c
$ sudo vim /etc/netplan/00-installer-config.yaml
$ sudo netplan apply
```

ws21:
![5.40 ws21 netplan config](pics/5.40%20ws21%20netplan%20config.png)

ws22:
![5.41 ws22 netplan config](pics/5.41%20ws22%20netplan%20config.png)

Перезагружаем ws11 с помощью reboot и проверяем получила ли машина адрес.

```c
$ reboot
$ ip a
```

![5.42 ws21 ip a](pics/5.42%20ws21%20ip%20a.png)

Пропингуем ws21 с ws22 по новому адресу, заданному dhcp.

![5.43 ws22 ping](pics/5.43%20ws22%20ping.png)

Пинг проходит.

#### `Указать MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: macaddress: 10:10:10:10:10:BA, dhcp4: true.`

```c
$ sudo vim /etc/netplan/00-installer-config.yaml
$ sudo netplan apply
```

ws11:
![5.44 ws11 netplan config](pics/5.44%20ws11%20netplan%20config.png)

`Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты.`

Настроим mac-адрес для ws11 в virtual box.

![5.45 ws11 mac address](pics/5.45%20ws11%20mac%20address.png)

Теперь настроим r1.

```c
$ sudo apt-get install ics-dhcp-server
```
Для начала определим сетевые интерфейсы и пропишем их в конфигурационный файл:

```c
$ sudo vim /etc/default/isc-dhcp-server
```
![5.46 r1 interfaces config](pics/5.46%20r1%20interfaces%20confg.png)

Теперь нужно отредактировать dhcpd.conf. Укажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети, диапазон IP адресов. Для жесткой привязки IP-MAC прямо в секции Subnet следует добавить описания хостов.

```c
$ sudo vim /etc/dhcp/dhcpd.conf
```
![5.47 r1 dhcp config](pics/5.47%20r1%20dhcp%20config.png)

Пропишем в файле resolv.conf прописать nameserver 8.8.8.8.

```c
$ sudo vim /etc/resolv.conf
```

![5.48 r1 nameserver](pics/5.48%20r1%20nameserver.png)

Перезагрузим службу DHCP командой:

```c
$ systemctl restart isc-dhcp-server
```

![5.49 r1 dhcp restart](pics/5.49%20r1%20dhcp%20restart.png)

Перезагрузим ws11 при помощи reboot и через ip a покажем, что она получила адрес.

```c
$ reboot
$ ip a
```

![5.50 ws11 ip a](pics/5.50%20ws11%20ip%20a.png)

Видим, что машина получила адрес, который мы задали в dhcpd.conf.

Пропингуем ws11 с r1. Видим, что пинг проходит.

![5.51 r1 ping](pics/5.51%20r1%20ping.png)

#### `Запросить с ws21 обновление ip адреса.`

Запросим с ws21 обновление ip адреса с помощью команды:
```c
$ sudo dhclient -v
```
> `dhclient` - запросить ip-адрес

> `-v` - будет выведена дополнительная информация

![5.53 ws21 dhclient](pics/5.53%20ws21%20dhclient.png)

ws21 ip до:
![5.52 ws21 ip a](pics/5.52%20ws21%20ip%20a.png)

ws21 ip после:
![5.54 ws21 ip a](pics/5.54%20ws21%20ip%20a.png)

## Part 7. NAT
#### `В файле /etc/apache2/ports.conf на ws22 и r1 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным.`

```c
$ sudo apt install apache2
$ sudo vim /etc/apache2/ports.conf
```

ws22:
![5.55 ws22 apache config](pics/5.55%20ws22%20apache%20config.png)

r1:
![5.56 r1 apache config](pics/5.56%20r1%20apache%20config.png)

#### `Запустить веб-сервер Apache командой service apache2 start на ws22 и r1.`

ws22:
![5.57 ws22 apache start](pics/5.57%20ws22%20apache%20start.png)

r1:
![5.58 r1 apache start](pics/5.58%20r1%20apache%20start.png)

#### `Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:`

#### 1) `удаление правил в таблице filter - iptables -F`

#### 2) `удаление правил в таблице "NAT" - iptables -F -t nat`

#### 3) `отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP`

Устанавливаем утилиту iptables, открываем файл, добавляем правила и делаем файл исполняемым.

```c
$ sudo apt install iptables
$ sudo vim /etc/firewall.sh
$ sudo chmod +x /etc/firewall.sh
$ sudo sh /etc/firewall.sh
```

r2:
![5.59 r2 firewall](pics/5.59%20r2%20firewall.png)

![5.60 r2 sh firewall](pics/5.60%20r2%20sh%20firewall.png)

#### `Проверить соединение между ws22 и r1 командой ping. При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1.`

ws22:
![5.61 ws22 ping](pics/5.61%20ws22%20ping.png)

Видим, что машины не пингуются.

#### `Добавить в файл ещё одно правило:`

#### 4) `разрешить маршрутизацию всех пакетов протокола ICMP`

#### `Проверить соединение между ws22 и r1 командой ping. При запуске файла с этими правилами, ws22 должна "пинговаться" с r1.`

r1:
![5.62 r2 firewall config](pics/5.62%20r2%20firewall%20config.png)

Пингуем ws22 с r1:
![5.64 ws22 ping](pics/5.64%20ws22%20ping.png)

Видим, что пинг проходит.

#### `Добавить в файл ещё два правила:`

#### 5) `включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)`

#### 6) `включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети`

![5.65 r2 firewall](pics/5.65%20r2%20firewall.png)

#### `Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой:`

```c
$ telnet [адрес] [порт]
```

> `Команда telnet используется для связи с другим хостом по протоколу TELNET.`

![5.66 ws22 telnet](pics/5.66%20ws22%20telnet.png)

#### `Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080).`

При этой проверке следует отключить на ws22 автоматическую выдачу ip enp0s3.

![5.67 ws22 netplan config](pics/5.67%20ws22%20netplan%20config.png)

![5.68 r1 telnet](pics/5.68%20r1%20telnet.png)

## Part 8. Bonus. Introduction to SSH Tunnels
### Дополнительно. Знакомство с SSH Tunnels

#### `Запустить на r2 фаервол с правилами из Части 7. Запустить веб-сервер Apache на ws22 только на localhost (то есть в файле /etc/apache2/ports.conf изменить строку Listen 80 на Listen localhost:80)`

ws22:
![5.69 ws22 localhost port](pics/5.69%20ws22%20localhost%20port.png)

![5.71 ws22 apache start](pics/5.71%20ws22%20apache%20start.png)

#### `Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21.`

Создаём соединение. Запускаем на машине ws22:

```c
$ ssh -p 2022 10.20.0.2
```
ws22:
![5.70 ssh connect](pics/5.70%20ws22%20ssh%20connect.png)

Оставаясь на машине ws22, устанавливаем соединение с сервером ws22 от машины ws21.

![5.72 ws22 ssh L](pics/5.72%20ws22%20ssh%20L.png)

![5.73 ws22 ssh L output](pics/5.73%20ws22%20ssh%20L%20output.png)

На машине ws21 запускаем утилиту telnet:
```c
$ telnet 127.0.0.1 8080
```

![5.78 ws21 telnet](pics/5.78%20ws21%20telnet.png)

```c
$ exit
```








